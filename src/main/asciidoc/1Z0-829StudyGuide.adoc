= Oracle Certified Professional Java SE 17 1Z0-829 Open Study Guide
:imagesdir: images
:source-highlighter: highlightjs
:toc: left
:toclevels: 4

== About this book

This book's primary purpose is to provide a straightforward and convenient way to prepare for the new Oracle exam - 1z0-829.
This book assumes that you already have experience with java because the information in some chapters is very concentrated.

== What is OCP?

This is professional JAVA https://education.oracle.com/java-se-17-developer/pexam_1Z0-829[certification] from Oracle.
You can use it as proof of your knowledge to your new employer.
There is a lot of controversy about whether it is necessary or not.
I believe that certification is necessary.
It gives you the possibility to structure your knowledge of java core.

== Why Java 17?

Java 17 is LTS release.
It stands for Long Time Support version.
So, support for this version will continue until the end of 2026.
The following Java 21 LTS release will appear in September 2023. Until it, you will have up-to-date certification.

== How to use this book

Book has 11 significant chapters.
Each chapter corresponds to a specific topic in the Oracle exam.
Each topic describes a problem in a maximum compressed format.
The topics are loosely connected to study them in any order.

== Content

=== Java basic concepts

==== OOP

Let's clarify the main computer concepts, to speak one language.

*Problem*: it is too hard to write programs in structured languages where an object's behavior is separated from object logic.

*Solution*: object-oriented programming.
The main idea is very simple. Everything in our universe we could describe as an object with condition and behavior.
Each condition variable is a field, each function, that represents object behavior is a method.

In structural languages, you have data inside structures and functions that can manipulate these data. But this functions
doesn't have any links for data.
In the oop approach you can immediately see what methods could work with your data because they are placed inside the object
description - class.

Class is a template for objects. It contains a description of fields and methods.
Their amount depends on your level of abstraction.

=== Handing date, time, text, numeric and boolean values

==== Math API

==== Text Blocks

*Problem*: it is too hard to write long strings with SQL query or HTML code.

*Solution*: give users a convenient way to write text blocks without unnecessary string concatenation.
You can simply paste snippets of code into strings.

So we can use such strings:

[source,java]
----
var source = """
    var message = "Hello, World";
    System.out.println(message + '!');
    """;
----

We don't need to use escape characters for quotes!
But, be careful on the exam, such code wouldn't compile:

[source,java]
----
// ERROR
var name = """text""";

// ERROR
var name = """first
second
""";
----

The position of the last three quotation marks will determine the last character in the sequence if they are right after the characters:

[source,java]
----
var name = """
first
second
""";
----

Will be - #"first\nsecond\n"#

And

[source,java]
----
var name = """
first
second""";
----

Will be - #"first\nsecond"#

If we want to adjust the indentation:

[source,java]
----
var names = """
first
second""".indent(1);
System.out.println("---");
System.out.println(names);
----

[source,bash]
----
Output:
---
 first
 second
----

==== Date-Time API

=== Controlling Program Flow

==== Switch statements and expressions

===== Switch expressions

*Problem*: switch blocks effectively replace the expression if-else, but they are very verbose.
It's very likely to forget the BREAK word at the end of an expression.
And it couldn't return values.

*Solution*: switch expression with lambda look syntax.

Let's see an example.
We want to write a function that returns String with animal sound:

[source,java]
----
public enum Animal {
    DOG,
    CAT,
    LION,
    BIRD;

    public String getSound(Animal animal) {
        return switch (animal) {
            case CAT, LION -> "Meow";
            case DOG -> "Bark-Bark";
            case BIRD -> "Chick-Chick";
        };
    }
}
----

You should agree.
The expression looks much more compact than the standard switch.
We could add default case for unpredictable inputs:

[source,java]
----
return switch (animal) {
    case CAT -> "Meow";
    case DOG -> "Bark-Bark";
    case BIRD -> "Chick-Chick";
    default -> "Unknown animal";
};
----

In this case, our switch expression doesn't cover all possible enum values, so we add a default case, like in the old-fashioned switch.
If we want to add more instructions in our lambda, we need to add curvy bracers and a new reserved word yield:

[source,java]
----
return switch (animal) {
    case CAT -> "Meow";
    case DOG -> "Bark-Bark";
    case BIRD -> {
        System.out.println("It's a Bird!");
        yield "Chick-Chick";
    }
    default -> "Unknown animal";
};
----

Why don't we use return?
Because return will throw us out of the expression.

As a usual switch, a new switch consumes such objects:
*char, byte, short, int, Character, Byte, Short, Integer, String, or an enum.*

=== Utilizing Java Object-Oriented Approach

==== Create classes and records

===== Records

*Problem*: DTO in java has a lot of boilerplate.

*Solution*: add special data classes to avoid boilerplate code like constructors, getters, etc.

Many developers like Lombok library because it makes such DTOs very compact.
But this library has some problems.
Users need more robust solutions on the language level.

Let's see how it looks with records:

[source,java]
----
public record Point(int x, int y) { }
----

This short expression gives us a lot of exciting functionality.

We have equals() and hashcode() methods implemented.
Also, we have the overloaded method toString() - it prints all variables in the record.
We have default constructor Point(int x, int y).
And we have getters - x() and y().
Because records were made for DTOs at first, they were made final and immutable.
But you can add new constructors, static and non-static methods.

Code

[source,java]
----
    public record Point(int x, int y) {
        Point() {
            this(0, 0);
        }

        boolean isYPositive() {
            return y >= 0;
        }

        static double dist(Point first, Point second) {
            return sqrt(pow(first.x() - second.x(), 2) + pow(first.y() - second.y(), 2));
        }
    }

    public static void main(String[] args) {
        var myPoint = new Point(1, 9);
        System.out.println(myPoint);
        System.out.println(myPoint.x());
        System.out.println(myPoint.y());
        System.out.println(myPoint.isYPositive());
        System.out.println("Equals\n");
        var myPoint2 = new Point(1, 9);
        System.out.println(myPoint == myPoint2);
        System.out.println(myPoint.equals(myPoint2));
        System.out.println(myPoint.equals(myPoint2));
        System.out.println(dist(myPoint, new Point()));
    }
----

Will output the following:

[source,bash]
----
Point[x=1, y=9]
1
9
true
Equals

false
true
true
9.055385138137417
----

==== Implement inheritance, including abstract and sealed classes

===== Sealed classes

*Problem*: Inheritance in Java is not limited.

For example, you have abstract class Animal, and your use it as a base class to build other classes like Dog and Cat.
But if someone creates a new class Car and decides to inherit it from Animal, you couldn't prevent it.

*Solution*: Sealed classes in Java 17.

Sealed classes enforce rules on inheritance:
[source,java]

----

public abstract sealed class Animal permits Dog, Cat {}
----

Now, only two classes can extend our base class.
We couldn't write such code:
[source,java]

----

public class Lion extends Animal {}
----

We need to add Lion class explicitly to Animal class signature, or we could get an error:

[source,bash]
----
java: class is not allowed to extend sealed class: dev.ivanov.book.Animal (as it is not listed in its permits clause)
----

Now, let's look at Cat and Dog classes.
We should mandatorily create them to compile our code.

Because we want to restrict inheritance, we need to foresee a situation where someone wants to inherit from our Cat and Dog classes to get functionality from the parent class.
And Java 17 gives us this possibility.
When we create Cat or Dog, we need to make these classes final - it prevents any inheritance from this class or mark them also sealed:

[source,java]
----

public final class Dog extends Animal {}
----

[source,java]
----

public sealed class Cat extends Animal permits Lion {}
----

Only the new Lion class can extend Cat.
In this way, we have protected the logic within our Cat class from erroneous inheritance.

In the case where such protection is not needed, and we want to give users unlimited inheritance options, it is worth adding the keyword non-sealed:

[source,java]
----

public non-sealed class Lion extends Cat {}
----

Now, class Lion may have any heirs.

It is especially worth noting that you can reduce the signature of a base class by simply putting all its descendants into the same file:
[source,java]

----

public abstract sealed class Animal {}
final class Bird extends Animal {}
----

Also, interfaces could be marked sealed:

[source,java]
----

public sealed interface Animal permits Bird, Cat, Dog {}
final class Bird implements Animal {}
----

But in this situation, we need explicitly declare all permits.

==== Instanceof operator and pattern matching

===== Pattern matching

Problem: using instanceof operator has excess casting
Solution: add a more convenient way without an explicit cast

Before java 16, we used such constructions:

[source,java]
----
if (o instanceof Cat) {
   System.out.println(((Cat) o).getName());
}
----

But it looks ugly because inside the 'if' statement, we already know the type of 'o'.
So, let's rewrite it:

[source,java]
----
if (o instanceof Cat cat) {
   System.out.println((cat.getName());
}
----

We also allowed to instantly use our cat variable inside if statement after 'instanceof' operator:

[source,java]
----
if (o instanceof Cat cat && cat.getAge() > 5) {
   System.out.println((cat.getName());
}
----

=== Access databases using JDBC

==== Control transactions using JDBC API
