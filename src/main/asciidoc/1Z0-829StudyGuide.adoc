= Oracle Certified Professional Java SE 17 1Z0-829 Open Study Guide
:imagesdir: images
:source-highlighter: highlightjs
:toc: left
:toclevels: 4

== About this book

This book's primary purpose is to provide a straightforward and convenient way to prepare for the new Oracle exam - 1z0-829.
This book assumes that you already have experience with java because the information in some chapters is very concentrated.

== What is OCP?

This is professional JAVA https://education.oracle.com/java-se-17-developer/pexam_1Z0-829[certification] from Oracle.
You can use it as proof of your knowledge to your new employer.
There is a lot of controversy about whether it is necessary or not.
I believe that certification is necessary.
It gives you the possibility to structure your knowledge of java core.

== Why Java 17?

Java 17 is LTS release.
It stands for Long Time Support version.
So, support for this version will continue until the end of 2026.
The following Java 21 LTS release will appear in September 2023. Until it, you will have up-to-date certification.

== How to use this book

Book has 11 significant chapters.
Each chapter corresponds to a specific topic in the Oracle exam.
Each topic describes a problem in a maximum compressed format.
The topics are loosely connected to study them in any order.

== Content

=== Java basic concepts

==== OOP

Let's clarify the main computer concepts, to speak one language.

*Problem*: it is too hard to write programs in structured languages where an object's behavior is separated from object logic.

*Solution*: object-oriented programming.
The main idea is very simple. Everything in our universe we could describe as an object with condition and behavior.
Each condition variable is a field, each function, that represents object behavior is a method.

In structural languages, you have data inside structures and functions that can manipulate these data. But this functions
doesn't have any links for data.
In the oop approach you can immediately see what methods could work with your data because they are placed inside the object
description - class.

Class is a template for objects. It contains a description of fields and methods.
Amount of fields and methods depends on your level of abstraction.

==== Packages and modules

*Problem*: we need a simple mechanism to store and reuse our and third party classes

*Solution*: Java has packages.

So, we could store our classes in separate directories. It gives us a possibility to avoid name clashes when we want to use
classes with the same names.
We can group classes by logic. Let's look at an example:

package dev.ivanov.math - in this package we could store classes with math functions

In the file system it just directories with such view: /dev/ivanov/math/

package dev.ivanov.math.calculator - in this package we could store classes with our calculator logic

In the file system it just directories with such view: /dev/ivanov/math/calculator

It's very important to know that there is not any connection between packages, even if they have similar package names.

*Problem*: We need to import two versions of the same package, to avoid version conflicts.
Or we have a library which contains some packages which we want to make completely unavailable for our customers.

*Solution*: Java has modules.

Unlike packages, modules are a group of packages. So we can unit some packages into modules and use them in our dependencies.

Each module has its own descriptor, that contains such information:

Name - the name of the module

Dependencies - list of other modules on which the module depends

Public packages - list of all the packages that could be accessed from outside the module

Services Offered - list of services that can be consumed by other modules

Services Consumed - allows the current module to be a service consumer

Reflection Permissions - explicitly allows other classes to use reflection to access closed package members

=== Handing date, time, text, numeric and boolean values

==== Var

*Problem*: Variable declarations can be too verbose.

*Solution*: add var keyword to declare variables.

Just look at the example:

[source,java]
----
class A{}
class SuperLongClassName extends A{}
void print(){
    SuperLongClassName superLongClassName = getSuperLongClassName();
    System.out.print(superLongClassName);
}
SuperLongClassName getSuperLongClassName(){
    return new SuperLongClassName();
}
----

At first, the var keyword can make the expression more compact:

[source,java]
----
var superLongClassName = getSuperLongClassName();
System.out.print(superLongClassName);
----

And add flexibility to refactoring. Now we can return another expression from the getSuperLongClassName()
method and the code inside the print() method won't need to be changed
[source,java]
----
void print(){
    var superLongClassName = getSuperLongClassName();
    System.out.print(superLongClassName);
}
A getSuperLongClassName(){
    return new SuperLongClassName();
}
----

Note! Such a declaration can only be applied within a method and must be initialized immediately:
[source,java]
----
class SuperLongClassName{
    var classVariable; // doesn't compile
    void print(var parameter){ // doesn't compile
            var localVariable; // doesn't compile
            var superLongClassName = getSuperLongClassName(); // ok
            System.out.print(superLongClassName);
        }
}
----

At compile time the var turns into the type we need.

==== Primitive types

*Problem*: Objects in Java are very heavy

*Solution*: add primitive types

Everything is an object!
You have heard this phrase more than once while learning java.

But 25 years ago, computers had problems. There were not enough memory and computing resources to run large programs.
For this reason, the OOP approach won, and the functional approach lost. Creating mutable objects saved memory. But it was not enough.
Numbers occur in any program in large quantities. And it was costly to make them as objects with their references. That's why there are eight types of primitive objects in the java.

|===
|Keyword |Type |Minimum value |Maximum value |Default value

|boolean
|8-bit value (true or false)
|-
|-
|false

|byte
|8-bit value
|-128
|127
|0

|short
|16-bit value
|-32,768
|32,767
|0

|int
|32-bit value
|-2,147,483,648
|2,147,483,647
|0

|long
|64-bit value
|-2^63
|2^63 - 1
|0L

|float
|32-bit value
|-
|-
|0.0f

|double
|64-bit value
|-
|-
|0.0

|char
|16-bit value
|0
|65,535
|0
|===

The compiler always uses the int and double types if the type is not explicitly specified.
This code will not work:

[source,java]
----
byte i = 10;
----

==== Operator precedence

For the exam, it is essential to know the operator precedence.
Just look as closely as possible at this table:

.Operator precedence
|===
|Operator |Symbols and examples

|Post-unary operators
|expression++, expression--

|Pre-unary operators
|++expression, --expression

|Other unary operators
|-, + ,!, ~

|Type casting
|(type)expression

|Multiplication & division
|*, /

|Division modulo
|%

|Addition & subtraction
|+, -

|Shift operations
|<<, >>, >>>

|Relational operators
|<, <=, >, >=

|Equal & not-equal operators
|==, !=

|Equal & not-equal operators
|==, !=

|Bit operators(from high to low)
|& ->  ^ ->  \|

|Conditional operators(from high to low)
|&& -> \|\|

|Ternary operator
|boolean expression ? expressionA : expressionB

|Assignment operators
|=, +=, -=, *=, /=, %=, <<\=, >>=, >>>=, &=, ^=
|===

TIP: The order of the operators is important. Always add parentheses to avoid confusion.

==== Date and time

==== Math API

==== Text Blocks

*Problem*: it is too hard to write long strings with SQL query or HTML code.

*Solution*: give users a convenient way to write text blocks without unnecessary string concatenation.
You can simply paste snippets of code into strings.

So we can use such strings:

[source,java]
----
var source = """
    var message = "Hello, World";
    System.out.println(message + '!');
    """;
----

We don't need to use escape characters for quotes!
But, be careful on the exam, such code wouldn't compile:

[source,java]
----
// ERROR
var name = """text""";

// ERROR
var name = """first
second
""";
----

The position of the last three quotation marks will determine the last character in the sequence if they are right after the characters:

[source,java]
----
var name = """
first
second
""";
----

Will be - #"first\nsecond\n"#

And

[source,java]
----
var name = """
first
second""";
----

Will be - #"first\nsecond"#

If we want to adjust the indentation:

[source,java]
----
var names = """
first
second""".indent(1);
System.out.println("---");
System.out.println(names);
----

[source,bash]
----
Output:
---
 first
 second
----

==== Date-Time API

=== Controlling Program Flow

==== Switch statements and expressions

===== Switch expressions

*Problem*: switch blocks effectively replace the expression if-else, but they are very verbose.
It's very likely to forget the BREAK word at the end of an expression.
And it couldn't return values.

*Solution*: switch expression with lambda look syntax.

Let's see an example.
We want to write a function that returns String with animal sound:

[source,java]
----
public enum Animal {
    DOG,
    CAT,
    LION,
    BIRD;

    public String getSound(Animal animal) {
        return switch (animal) {
            case CAT, LION -> "Meow";
            case DOG -> "Bark-Bark";
            case BIRD -> "Chick-Chick";
        };
    }
}
----

You should agree.
The expression looks much more compact than the standard switch.
We could add default case for unpredictable inputs:

[source,java]
----
return switch (animal) {
    case CAT -> "Meow";
    case DOG -> "Bark-Bark";
    case BIRD -> "Chick-Chick";
    default -> "Unknown animal";
};
----

In this case, our switch expression doesn't cover all possible enum values, so we add a default case, like in the old-fashioned switch.
If we want to add more instructions in our lambda, we need to add curvy bracers and a new reserved word yield:

[source,java]
----
return switch (animal) {
    case CAT -> "Meow";
    case DOG -> "Bark-Bark";
    case BIRD -> {
        System.out.println("It's a Bird!");
        yield "Chick-Chick";
    }
    default -> "Unknown animal";
};
----

Why don't we use return?
Because return will throw us out of the expression.

As a usual switch, a new switch consumes such objects:
*char, byte, short, int, Character, Byte, Short, Integer, String, or an enum.*

=== Utilizing Java Object-Oriented Approach

==== Create classes and records

===== Records

*Problem*: DTO in java has a lot of boilerplate.

*Solution*: add special data classes to avoid boilerplate code like constructors, getters, etc.

Many developers like Lombok library because it makes such DTOs very compact.
But this library has some problems.
Users need more robust solutions on the language level.

Let's see how it looks with records:

[source,java]
----
public record Point(int x, int y) { }
----

This short expression gives us a lot of exciting functionality.

We have equals() and hashcode() methods implemented.
Also, we have the overloaded method toString() - it prints all variables in the record.
We have default constructor Point(int x, int y).
And we have getters - x() and y().
Because records were made for DTOs at first, they were made final and immutable.
But you can add new constructors, static and non-static methods.

Code

[source,java]
----
    public record Point(int x, int y) {
        Point() {
            this(0, 0);
        }

        boolean isYPositive() {
            return y >= 0;
        }

        static double dist(Point first, Point second) {
            return sqrt(pow(first.x() - second.x(), 2) + pow(first.y() - second.y(), 2));
        }
    }

    public static void main(String[] args) {
        var myPoint = new Point(1, 9);
        System.out.println(myPoint);
        System.out.println(myPoint.x());
        System.out.println(myPoint.y());
        System.out.println(myPoint.isYPositive());
        System.out.println("Equals\n");
        var myPoint2 = new Point(1, 9);
        System.out.println(myPoint == myPoint2);
        System.out.println(myPoint.equals(myPoint2));
        System.out.println(myPoint.equals(myPoint2));
        System.out.println(dist(myPoint, new Point()));
    }
----

Will output the following:

[source,bash]
----
Point[x=1, y=9]
1
9
true
Equals

false
true
true
9.055385138137417
----

==== Implement inheritance, including abstract and sealed classes

===== Sealed classes

*Problem*: Inheritance in Java is not limited.

For example, you have abstract class Animal, and your use it as a base class to build other classes like Dog and Cat.
But if someone creates a new class Car and decides to inherit it from Animal, you couldn't prevent it.

*Solution*: Sealed classes in Java 17.

Sealed classes enforce rules on inheritance:
[source,java]

----

public abstract sealed class Animal permits Dog, Cat {}
----

Now, only two classes can extend our base class.
We couldn't write such code:
[source,java]

----

public class Lion extends Animal {}
----

We need to add Lion class explicitly to Animal class signature, or we could get an error:

[source,bash]
----
java: class is not allowed to extend sealed class: dev.ivanov.book.Animal (as it is not listed in its permits clause)
----

Now, let's look at Cat and Dog classes.
We should mandatorily create them to compile our code.

Because we want to restrict inheritance, we need to foresee a situation where someone wants to inherit from our Cat and Dog classes to get functionality from the parent class.
And Java 17 gives us this possibility.
When we create Cat or Dog, we need to make these classes final - it prevents any inheritance from this class or mark them also sealed:

[source,java]
----

public final class Dog extends Animal {}
----

[source,java]
----

public sealed class Cat extends Animal permits Lion {}
----

Only the new Lion class can extend Cat.
In this way, we have protected the logic within our Cat class from erroneous inheritance.

In the case where such protection is not needed, and we want to give users unlimited inheritance options, it is worth adding the keyword non-sealed:

[source,java]
----

public non-sealed class Lion extends Cat {}
----

Now, class Lion may have any heirs.

It is especially worth noting that you can reduce the signature of a base class by simply putting all its descendants into the same file:
[source,java]

----

public abstract sealed class Animal {}
final class Bird extends Animal {}
----

Also, interfaces could be marked sealed:

[source,java]
----

public sealed interface Animal permits Bird, Cat, Dog {}
final class Bird implements Animal {}
----

But in this situation, we need explicitly declare all permits.

==== Instanceof operator and pattern matching

===== Pattern matching

Problem: using instanceof operator has excess casting
Solution: add a more convenient way without an explicit cast

Before java 16, we used such constructions:

[source,java]
----
if (o instanceof Cat) {
   System.out.println(((Cat) o).getName());
}
----

But it looks ugly because inside the 'if' statement, we already know the type of 'o'.
So, let's rewrite it:

[source,java]
----
if (o instanceof Cat cat) {
   System.out.println((cat.getName());
}
----

We also allowed to instantly use our cat variable inside if statement after 'instanceof' operator:

[source,java]
----
if (o instanceof Cat cat && cat.getAge() > 5) {
   System.out.println((cat.getName());
}
----

=== Access databases using JDBC

==== Control transactions using JDBC API
