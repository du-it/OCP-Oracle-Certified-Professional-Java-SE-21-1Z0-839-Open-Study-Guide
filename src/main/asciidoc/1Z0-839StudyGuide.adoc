= Oracle Certified Professional Java SE 21 1Z0-839 Open Study Guide
:imagesdir: images
:source-highlighter: highlightjs
:toc: left
:toclevels: 4

== About this book

This book's primary purpose is to provide a straightforward and convenient way to prepare for the new Oracle exam - 1z0-839.
This book assumes that you already have experience with java because the information in some chapters is very concentrated.

== What is OCP?

This is professional JAVA https://education.oracle.com/java-se-21-developer/pexam_1Z0-839[certification] from Oracle.
You can use it as proof of your knowledge to your new employer.
There is a lot of controversy about whether it is necessary or not.
I believe that certification is necessary.
It gives you the possibility to structure your knowledge of java core.

== Why Java 21?

Java 21 is LTS release.
It stands for Long Time Support version.
So, support for this version will continue until the end of 2029.
The following Java 24 LTS release will appear in September 2026. Until it, you will have up-to-date certification.

== How to use this book

Book has 11 significant chapters.
Each chapter corresponds to a specific topic in the Oracle exam.
Each topic describes a problem in a maximum compressed format.
The topics are loosely connected to study them in any order.

== Content

=== Java basic concepts

==== OOP

Let's clarify the main computer concepts, to speak one language.

*Problem*: it is too hard to write programs in structured languages where an object's behavior is separated from object logic.

*Solution*: object-oriented programming.
The main idea is very simple. Everything in our universe we could describe as an object with condition and behavior.
Each condition variable is a field, each function, that represents object behavior is a method.

In structural languages, you have data inside structures and functions that can manipulate these data. But this functions
doesn't have any links for data.
In the oop approach you can immediately see what methods could work with your data because they are placed inside the object
description - class.

Class is a template for objects. It contains a description of fields and methods.
Amount of fields and methods depends on your level of abstraction.

==== Packages and modules

*Problem*: we need a simple mechanism to store and reuse our and third party classes

*Solution*: Java has packages.

So, we could store our classes in separate directories. It gives us a possibility to avoid name clashes when we want to use
classes with the same names.
We can group classes by logic. Let's look at an example:

package dev.ivanov.math - in this package we could store classes with math functions

In the file system it just directories with such view: /dev/ivanov/math/

package dev.ivanov.math.calculator - in this package we could store classes with our calculator logic

In the file system it just directories with such view: /dev/ivanov/math/calculator

It's very important to know that there is not any connection between packages, even if they have similar package names.

*Problem*: We need to import two versions of the same package, to avoid version conflicts.
Or we have a library which contains some packages which we want to make completely unavailable for our customers.

*Solution*: Java has modules.

Unlike packages, modules are a group of packages. So we can unit some packages into modules and use them in our dependencies.

Each module has its own descriptor, that contains such information:

Name - the name of the module

Dependencies - list of other modules on which the module depends

Public packages - list of all the packages that could be accessed from outside the module

Services Offered - list of services that can be consumed by other modules

Services Consumed - allows the current module to be a service consumer

Reflection Permissions - explicitly allows other classes to use reflection to access closed package members

=== Handing date, time, text, numeric and boolean values

==== Use primitives and wrapper classes including Math API, parentheses, type promotion, and casting to evaluate arithmetic and boolean expressions

==== Var

*Problem*: Variable declarations can be too verbose.

*Solution*: add var keyword to declare variables.

Just look at the example:

[source,java]
----
class A{}
class SuperLongClassName extends A{}
void print(){
    SuperLongClassName superLongClassName = getSuperLongClassName();
    System.out.print(superLongClassName);
}
SuperLongClassName getSuperLongClassName(){
    return new SuperLongClassName();
}
----

At first, the var keyword can make the expression more compact:

[source,java]
----
var superLongClassName = getSuperLongClassName();
System.out.print(superLongClassName);
----

And add flexibility to refactoring. Now we can return another expression from the getSuperLongClassName()
method and the code inside the print() method won't need to be changed
[source,java]
----
void print(){
    var superLongClassName = getSuperLongClassName();
    System.out.print(superLongClassName);
}
A getSuperLongClassName(){
    return new SuperLongClassName();
}
----

Note! Such a declaration can only be applied within a method and must be initialized immediately:
[source,java]
----
class SuperLongClassName{
    var classVariable; // doesn't compile
    void print(var parameter){ // doesn't compile
            var localVariable; // doesn't compile
            var superLongClassName = getSuperLongClassName(); // ok
            System.out.print(superLongClassName);
        }
}
----

At compile time the var turns into the type we need.

==== Primitive types

*Problem*: Objects in Java are very heavy

*Solution*: add primitive types

Everything is an object!
You have heard this phrase more than once while learning java.

But 25 years ago, computers had problems. There were not enough memory and computing resources to run large programs.
For this reason, the OOP approach won, and the functional approach lost. Creating mutable objects saved memory. But it was not enough.
Numbers occur in any program in large quantities. And it was costly to make them as objects with their references. That's why there are eight types of primitive objects in the java.

|===
|Keyword |Type |Minimum value |Maximum value |Default value

|boolean
|8-bit value (true or false)
|-
|-
|false

|byte
|8-bit value
|-128
|127
|0

|short
|16-bit value
|-32,768
|32,767
|0

|int
|32-bit value
|-2,147,483,648
|2,147,483,647
|0

|long
|64-bit value
|-2^63
|2^63 - 1
|0L

|float
|32-bit value
|-
|-
|0.0f

|double
|64-bit value
|-
|-
|0.0

|char
|16-bit value
|0
|65,535
|0
|===

The compiler always uses the int and double types if the type is not explicitly specified.
This code will not work:

[source,java]
----
byte i = 10;
----

*int* is the basic type in java for integer calculations.
Therefore, if you perform operations on different smaller types(byte, short, and char), the compiler will try to convert them to the *int* type.

If you want to perform operations on different larger types(long, float, and double), you need to explicitly specify the type.

==== Operator precedence

For the exam, it is essential to know the operator precedence.
Just look as closely as possible at this table:

.Operator precedence
|===
|Operator |Symbols and examples

|Post-unary operators
|expression++, expression--

|Pre-unary operators
|++expression, --expression

|Other unary operators
|-, + ,!, ~

|Type casting
|(type)expression

|Multiplication & division
|*, /

|Division modulo
|%

|Addition & subtraction
|+, -

|Shift operations
|<<, >>, >>>

|Relational operators
|<, <=, >, >=

|Equal & not-equal operators
|==, !=

|Equal & not-equal operators
|==, !=

|Bit operators(from high to low)
|& ->  ^ ->  \|

|Conditional operators(from high to low)
|&& -> \|\|

|Ternary operator
|boolean expression ? expressionA : expressionB

|Assignment operators
|=, +=, -=, *=, /=, %=, <<\=, >>=, >>>=, &=, ^=
|===

TIP: The order of the operators is important. Always add parentheses to avoid confusion.

==== Math API

Math API is very useful for calculations.
For exam you need to know the following:
Java has min() and max() methods for the int, float, long and double types.
Method round():

[source,java]
----
public static long round(double num)
public static int round(float num)
System.out.println(Math.round(3.5)) // 4
System.out.println(Math.round(3.45)) // 3
----

For double values we have two additional methods:

[source,java]
----
public static double ceil(double num)
public static double floor(double num)
Math.ceil(3.14) // 4
Math.floor(3.14) // 3
----

*Math.random()* method return a random double value between 0 and 1.
But I urge you to use the next methods:

[source,java]
----
new Random().ints();
new Random().doubles();
----
this is beautiful method for generating random numbers.

==== Manipulate text, including text blocks, using String and StringBuilder classes

==== String and StringBuilder classes

String and StringBuilder classes are very useful for manipulating text.
String is immutable, while StringBuilder is mutable.
String is a sequence of characters.


==== Text Blocks

*Problem*: it is too hard to write long strings with SQL query or HTML code.

*Solution*: give users a convenient way to write text blocks without unnecessary string concatenation.
You can simply paste snippets of code into strings.

So we can use such strings:

[source,java]
----
var source = """
    var message = "Hello, World";
    System.out.println(message + '!');
    """;
----

We don't need to use escape characters for quotes!
But, be careful on the exam, such code wouldn't compile:

[source,java]
----
// ERROR
var name = """text""";

// ERROR
var name = """first
second
""";
----

The position of the last three quotation marks will determine the last character in the sequence if they are right after the characters:

[source,java]
----
var name = """
first
second
""";
----

Will be - #"first\nsecond\n"#

And

[source,java]
----
var name = """
first
second""";
----

Will be - #"first\nsecond"#

If we want to adjust the indentation:

[source,java]
----
var names = """
first
second""".indent(1);
System.out.println("---");
System.out.println(names);
----

[source,bash]
----
Output:
---
 first
 second
----

==== Manipulate date, time, duration, period, instant and time-zone objects using Date-Time API

==== Date-Time API
*Problem*: Every program needs to know the current date and time.

*Solution*: java new Date-Time API

In the exam, there are always questions on it. The new API that has appeared in java since version 8 makes it very easy to work with time. Here are the basic things you should know about it.
We have 4 types of dates:

.Local Dates
|===
|Class name |Features

|LocalDate
|Date without time and time zone

|LocalTime
|Time without date and time zone

|LocalDateTime
|Date and time without time zone

|ZonedDateTime
|Date and time with time zone
|===

Every class has a convenient static method to get an object with the current date and time: *now()*
We could create an objects with current date and time:

[source,java]
----
//Most popular methods
static LocalDate of(int year, int month, int day)
static LocalTime of(int hour, int minute, int second)
LocalDateTime of(int year, Month month, int dayOfMonth, int hour, int minute)
LocalDateTime of(LocalDate date, LocalTime time)
ZonedDateTime of(LocalDateTime dateTime, ZoneId zone)
//etc
----

*Problem*: It is super hard to add days to a date in previous date-time API.

*Solution*: In my opinion, the most convenient methods are methods of manipulating dates and times.

Just check the following methods:

[source,java]
var date = LocalDateTime.now().plusDays(1).plusWeeks(2).plusMonths(3).plusYears(4).minusHours(5).minusMinutes(6);

*Problem*: It is super hard to work with periods and time intervals.

*Solution*: Period and Duration classes.

[source,java]
----
Period.ofYears(1); // every year
Period.ofMonths(2); // every two months
Period.ofWeeks(3); // every three weeks
Period.ofDays(4); // every four days
Period.of(1, 2, 3); // every 1 year, 2 months, 3 weeks

var date = LocalDate.now().plus(Period.of(1, 2, 3));
----

[source,java]
----
Duration.ofDays(1); // 1 day
Duration.ofHours(1); // every hour
Duration.ofMinutes(2); // every two minutes
Duration.ofSeconds(3); // every three seconds
Duration.of(4, ChronoUnit.SECONDS); // every 4 seconds
Duration.ofMillis(10); // every 10 milliseconds
Duration.ofNanos(10); // every 10 nanoseconds
var dateTime = LocalDateTime.now().plus(Duration.of(1, ChronoUnit.SECONDS));
----

*Problem*: sometimes we need to work with time points, for example, when we want to know the time when the next day starts.

*Solution*: Instant class

.Quote from the official documentation:
----
An instantaneous point on the time-line.
This class models a single instantaneous point on the time-line. This might be used to record event time-stamps in the application.
----

[source,java]
----
var time1 = Instant.now();
var time2 = ZonedDateTime.now().toInstant();
var duration = Duration.between(time1, time2);
----

=== Controlling Program Flow

==== Create program flow control constructs including if/else, switch statements and expressions, loops, and break and continue statements

==== Switch statements and expressions

===== Switch expressions

*Problem*: switch blocks effectively replace the expression if-else, but they are very verbose.
It's very likely to forget the BREAK word at the end of an expression.
And it couldn't return values.

*Solution*: switch expression with lambda look syntax.

Let's see an example.
We want to write a function that returns String with animal sound:

[source,java]
----
public enum Animal {
    DOG,
    CAT,
    LION,
    BIRD;

    public String getSound(Animal animal) {
        return switch (animal) {
            case CAT, LION -> "Meow";
            case DOG -> "Bark-Bark";
            case BIRD -> "Chick-Chick";
        };
    }
}
----

You should agree.
The expression looks much more compact than the standard switch.
We could add default case for unpredictable inputs:

[source,java]
----
return switch (animal) {
    case CAT -> "Meow";
    case DOG -> "Bark-Bark";
    case BIRD -> "Chick-Chick";
    default -> "Unknown animal";
};
----

In this case, our switch expression doesn't cover all possible enum values, so we add a default case, like in the old-fashioned switch.
If we want to add more instructions in our lambda, we need to add curvy bracers and a new reserved word yield:

[source,java]
----
return switch (animal) {
    case CAT -> "Meow";
    case DOG -> "Bark-Bark";
    case BIRD -> {
        System.out.println("It's a Bird!");
        yield "Chick-Chick";
    }
    default -> "Unknown animal";
};
----

Why don't we use return?
Because return will throw us out of the expression.

===== Pattern Matching for switch

Pattern Matching for switch supports so-called patterns in case branches, which can be supplemented with conditions using the new 'when' keyword:

[source,java]
----
Object obj = …
return switch (obj) {
case Integer i when i > 0 -> String.format("positive int %d", i);
case Integer i -> String.format("int %d", i);
case String s -> String.format("String %s", s);
default -> obj.toString();
};
----
It also allows for null matching, typically achieved through an explicit 'case null' branch. However, if there is no 'case null' branch, a switch statement with null passed to it will invariably throw a NullPointerException, even if a default branch exists. Notably, the 'null' and 'default' branches can be combined.
[source,java]
----
Object obj = null;
switch (obj) { // NullPointerException
    case String s -> System.out.println("String: " + s);
    default -> System.out.println("Other");
}
----

[source,java]
----
String str = …
switch (str) {
    case "Foo", "Bar" -> System.out.println("Foo or Bar");
    case null, default -> System.out.println("Null or other");
}
----

The new pattern-matching feature in Witch has several limitations:

All switches (except those correct before Java 21) must be exhaustive, meaning the branches should cover all possible cases. For example, this can be resolved by adding an 'Object o' or 'default' branch to the above example.
[source,java]
----
Object obj = …
switch (obj) { // 'switch' expression does not cover all possible input values
    case String s -> System.out.println(s.length());
    case Integer i -> System.out.println(i);
};
----

The order of case branches is crucial; no branch should be dominated by another branch preceding it. For instance, since 'CharSequence' is a broader type than 'String', its branch should be placed after the 'String' branch.
[source,java]
----
return switch (obj) {
    case CharSequence cs -> // more wide
        "sequence of length " + cs.length();
    case String s -> // unreachable
        "string of length " + s.length();
    default -> "other";
 };
----

Multiple patterns in the same branch are not supported.
[source,java]
----
return switch (obj) {
    case String s, Integer i -> "str/int";
    default -> "other";
 };
----

=== Utilizing Java Object-Oriented Approach

==== Declare and instantiate Java objects including nested class objects, and explain the object life-cycle including creation, reassigning references, and garbage collection

==== Create classes and records, and define and use instance and static fields and methods, constructors, and instance and static initializers

==== Create classes and records

===== Records

*Problem*: DTO in java has a lot of boilerplate.

*Solution*: add special data classes to avoid boilerplate code like constructors, getters, etc.

Many developers like Lombok library because it makes such DTOs very compact.
But this library has some problems.
Users need more robust solutions on the language level.

Let's see how it looks with records:

[source,java]
----
public record Point(int x, int y) { }
----

This short expression gives us a lot of exciting functionality.

We have equals() and hashcode() methods implemented.
Also, we have the overloaded method toString() - it prints all variables in the record.
We have default constructor Point(int x, int y).
And we have getters - x() and y().
Because records were made for DTOs at first, they were made final and immutable.
But you can add new constructors, static and non-static methods.

Code

[source,java]
----
    public record Point(int x, int y) {
        Point() {
            this(0, 0);
        }

        boolean isYPositive() {
            return y >= 0;
        }

        static double dist(Point first, Point second) {
            return sqrt(pow(first.x() - second.x(), 2) + pow(first.y() - second.y(), 2));
        }
    }

    public static void main(String[] args) {
        var myPoint = new Point(1, 9);
        System.out.println(myPoint);
        System.out.println(myPoint.x());
        System.out.println(myPoint.y());
        System.out.println(myPoint.isYPositive());
        System.out.println("Equals\n");
        var myPoint2 = new Point(1, 9);
        System.out.println(myPoint == myPoint2);
        System.out.println(myPoint.equals(myPoint2));
        System.out.println(myPoint.equals(myPoint2));
        System.out.println(dist(myPoint, new Point()));
    }
----

Will output the following:

[source,bash]
----
Point[x=1, y=9]
1
9
true
Equals

false
true
true
9.055385138137417
----

==== Implement inheritance, including abstract and sealed classes

===== Sealed classes

*Problem*: Inheritance in Java is not limited.

For example, you have abstract class Animal, and your use it as a base class to build other classes like Dog and Cat.
But if someone creates a new class Car and decides to inherit it from Animal, you couldn't prevent it.

*Solution*: Sealed classes in Java 17.

Sealed classes enforce rules on inheritance:
[source,java]

----

public abstract sealed class Animal permits Dog, Cat {}
----

Now, only two classes can extend our base class.
We couldn't write such code:
[source,java]

----

public class Lion extends Animal {}
----

We need to add Lion class explicitly to Animal class signature, or we could get an error:

[source,bash]
----
java: class is not allowed to extend sealed class: dev.ivanov.book.Animal (as it is not listed in its permits clause)
----

Now, let's look at Cat and Dog classes.
We should mandatorily create them to compile our code.

Because we want to restrict inheritance, we need to foresee a situation where someone wants to inherit from our Cat and Dog classes to get functionality from the parent class.
And Java 17 gives us this possibility.
When we create Cat or Dog, we need to make these classes final - it prevents any inheritance from this class or mark them also sealed:

[source,java]
----

public final class Dog extends Animal {}
----

[source,java]
----

public sealed class Cat extends Animal permits Lion {}
----

Only the new Lion class can extend Cat.
In this way, we have protected the logic within our Cat class from erroneous inheritance.

In the case where such protection is not needed, and we want to give users unlimited inheritance options, it is worth adding the keyword non-sealed:

[source,java]
----

public non-sealed class Lion extends Cat {}
----

Now, class Lion may have any heirs.

It is especially worth noting that you can reduce the signature of a base class by simply putting all its descendants into the same file:
[source,java]

----

public abstract sealed class Animal {}
final class Bird extends Animal {}
----

Also, interfaces could be marked sealed:

[source,java]
----

public sealed interface Animal permits Bird, Cat, Dog {}
final class Bird implements Animal {}
----

But in this situation, we need explicitly declare all permits.

==== Implement overloading, including var-arg methods

==== Understand variable scopes, use local variable type inference, apply encapsulation, and make objects immutable

==== Implement inheritance, including abstract and sealed classes. Override methods, including that of Object class. Implement polymorphism and differentiate object type versus reference type. Perform type casting, identify object types using instanceof operator and pattern matching

==== Create and use interfaces, identify functional interfaces, and utilize private, static, and default interface methods

==== Create and use enumerations with fields, methods and constructors

==== Instanceof operator and pattern matching

===== Pattern matching

Problem: using instanceof operator has excess casting
Solution: add a more convenient way without an explicit cast

Before java 16, we used such constructions:

[source,java]
----
if (o instanceof Cat) {
   System.out.println(((Cat) o).getName());
}
----

But it looks ugly because inside the 'if' statement, we already know the type of 'o'.
So, let's rewrite it:

[source,java]
----
if (o instanceof Cat cat) {
   System.out.println((cat.getName());
}
----

We also allowed to instantly use our cat variable inside if statement after 'instanceof' operator:

[source,java]
----
if (o instanceof Cat cat && cat.getAge() > 5) {
   System.out.println((cat.getName());
}
----

===== Record Patterns
Record patterns enable concise record value deconstruction:
[source,java]
----
record Point(int x, int y) {}

static void print(Object obj) {
    if (obj instanceof Point(int x, int y)) {
       println(x + " " + y);
    }
}
----
Also achievable through a switch statement:
[source,java]
----
static void print(Object obj) {
    switch (obj) {
        case Point(int x, int y) -> println(x + " " + y);
        default -> System.out.println("Not a point");
    }
}
----
Their ability to nest enhances their flexibility:
[source,java]
----
record Point(int x, int y) {}
enum Color { RED, GREEN, BLUE }
record ColoredPoint(Point p, Color c) {}
record Rectangle(ColoredPoint first, ColoredPoint second) {}

static void print(Rectangle r) {
    if (r instanceof Rectangle(ColoredPoint(Point p, var c), var coloredPoint)) { // We are using var to omit info about class
        println("Current color:" + c);
    }
}
----
They seamlessly integrate with type-based patterns:
[source,java]
----
record Point(Object obj) {}

static void test(Point point) {
    switch (point) {
        case Point(String s) -> println("string: " + s);
        case Point(Object o) -> println("other: " + o);
    }
}
----
They also accommodate generic record type outputs:

=== Handling Exceptions

==== Handle exceptions using try/catch/finally, try-with-resources, and multi-catch blocks, including custom exceptions

=== Working with Arrays and Collections

==== Create Java arrays, List, Set, Map, and Deque collections, and add, remove, update, retrieve and sort their elements

=== Working with Streams and Lambda expressions

==== Use Java object and primitive Streams, including lambda expressions implementing functional interfaces, to supply, filter, map, consume, and sort data

==== Perform decomposition, concatenation and reduction, and grouping and partitioning on sequential and parallel streams

=== Packaging and deploying Java code and use the Java Platform Module System

==== Define modules and their dependencies, expose module content including for reflection. Define services, producers, and consumers

==== Compile Java code, produce modular and non-modular jars, runtime images, and implement migration using unnamed and automatic modules

=== Managing concurrent code execution

==== Virtual threads
*Problem*: Creating a new thread is very expensive, forcing developers to employ various strategies—such as thread pools and reactive programming—to effectively utilize existing threads.

*Solution*: Virtual threads.

Virtual threads are designed to be lightweight, enabling the creation of vast quantities (up to millions) of instances. This feature simplifies the development of efficient programs by allowing a straightforward "one request - one thread" or "one task - one thread" model, eliminating the need for intricate asynchronous or reactive programming techniques. Additionally, transitioning existing code to virtual threads is intended to be straightforward. Since virtual threads are instances of the current *java.lang.Thread* class, they maintain high compatibility with traditional threads, including support for stack traces, the interrupt() method, ThreadLocal, and more.

Virtual threads operate atop standard threads and are recognized only by the Java Virtual Machine (JVM), not by the operating system, which is why they are termed "virtual." The physical thread that a virtual thread runs on is referred to as the host thread. Unlike platform threads that depend on the operating system's scheduler, virtual threads are managed by the *ForkJoinPool* scheduler. When a virtual thread engages in a blocking operation, it detaches from its host thread. This detachment allows the host thread to take on another virtual thread and proceed with execution. This mechanism, coupled with the low cost of managing virtual threads, greatly enhances their scalability. However, there are currently two notable exceptions: synchronized blocks and Java Native Interface (JNI) operations. In these cases, a virtual thread cannot detach from its host thread due to its binding, which may affect scalability. To fully leverage virtual threads, it is advisable to minimize the use of synchronized blocks and JNI operations, especially those that are executed frequently or have lengthy durations.

==== Create worker threads using Runnable and Callable, manage the thread lifecycle, including automations provided by different Executor services and concurrent API

==== Develop thread-safe code, using different locking mechanisms and concurrent API

==== Process Java collections concurrently including the use of parallel streams

=== Using Java I/O API

==== Read and write console and file data using I/O Streams

==== Serialize and de-serialize Java objects

==== Create, traverse, read, and write Path objects and their properties using java.nio.file API

=== Access databases using JDBC

==== Create connections, create and execute basic, prepared and callable statements, process query results and control transactions using JDBC API

==== Control transactions using JDBC API

=== Implementing Localization

==== Implement localization using locales, resource bundles, parse and format messages, dates, times, and numbers including currency and percentage values

(c) Roman Ivanov
